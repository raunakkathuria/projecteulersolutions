(function () {

/*
    function to calculate the time taken to execute a function,
    created as a wrapper for function calls to measure performance
 */
    function profiler(func) {
        return function() {
            let start = performance.now(),
                // as I am not passing arguments so using it directly
                // else use it like this let args = Array.from(arguments))
                returnVal = func.apply(this, arguments),
                end = performance.now(),
                duration = Number(end - start).toFixed(4),
                funcName = func.name;

            console.log(`       == Time take for ${funcName} was ${duration} ms`);
            return returnVal;
        };
    }

/*
    https://projecteuler.net/problem=1
    ----------------------------------
    Multiples of 3 and 5

    Problem Statement:
        If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
        The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.
 */

    /*
     * this is normal looping based on input provided so time will increase linearly depending on input
     * as size of input increases time to calculate will increase
     *
     * O(n)
     */
    function linearWay(n) {
        let sum = 0;
        for (let i = 0; i < n; i++) {
          if (i % 3 === 0 || i % 5 === 0) {
            sum += i;
          }
        }
        return sum;
    }

    console.log("#### Problem1 (https://projecteuler.net/problem=1) ####");
    var profile = profiler(linearWay);
    console.log("       linear result for 1000", profile.call(null, 1000));
    console.log("       linear result for 10000", profile.call(null, 10000));
    console.log("       linear result for 1000000", profile.call(null, 1000000));
    console.log("");

    /*
     * this I learned later by looking on how to optimize it with the help of their suggestion, implemented
     * it just for learning it, got to learn gauss formula :)
     *
     * linearWay can have issues if n is very large, we can also solve it by making use of Gauss formula
     * i.e calculate sum individually for 3, 5, 15 using gauss formula, this way we can get rid of
     * looping through input
     *
     * Gauss formula to calculate sum all numbers till num is (num * (num + 1))/2
     *
     * with this way we have made this function independent of size of input
     *
     * O(1)
     */
    function sumDivisibleBy(num, n) {
        if (Number.isInteger(num) && Number.isInteger(n)) {
            let p = parseInt(num/n);
            return parseInt(n * (p * (p + 1)) / 2);
        }
        return 0;
    }

    function calculateSumGaussWay(num) {
        return sumDivisibleBy(num, 3) + sumDivisibleBy(num, 5) - sumDivisibleBy(num, 15);
    }

    profile = profiler(calculateSumGaussWay);
    console.log("       gauss way result for 1000", profile.call(null, 999));
    console.log("       gauss way result for 10000", profile.call(null, 9999));
    console.log("       gauss way result for 1000000", profile.call(null, 999999));

    console.log(">>>>>>> ------------------------------------------------------------------------------ <<<<<<<");

/*
    https://projecteuler.net/problem=2
    ----------------------------------
    Even Fibonacci numbers

    Problem Statement:
        Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
            1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 */

    /*
     * as limit is defined so no need to pass any number for fibonacci, we will terminate based on limit 4000000
     * as we are looping so it will have linear time complexity so it will be
     * O(n) - increases with size of input
     */
    function fibonacciLinear(limit) {
        let a = 1,
            b = 0,
            sum = 0;

        while (a < limit) {
            // with es6 destructor no need to create temporary variable
            [a, b] = [b + a, a];

            // check if its even
            if (a % 2 === 0) {
                sum += a;
            }
        }

        return sum;
    }

    console.log("#### Problem2 (https://projecteuler.net/problem=2) ####");
    profile = profiler(fibonacciLinear);
    console.log("       linear result for limit 4000000", profile.call(null, 4000000));
    console.log("");

    /*
     * while analyzing the fibonacci series I came to realize one pattern for even that every third number is even
     * i never noticed it (eureka feeling :))
     * so with this function we can eliminate looping through all elements to check if they are even or not hence time
     * will reduce accordingly like O(n/3) as compared to previous one
     */
    function fibonacciEfficient(limit) {
        let a = 1,
            b = 1, // assigning b so that series start with 1, 1 to be consistent
            c = a + b, // 2
            sum = 0;

        while (c < limit) {
            sum += c;
            // for next loop 3 5 8 so a will be 3, b will be 5 and c will be 8
            a = b + c; // 1 + 2
            b = a + c; // 3 + 2
            c = a + b; // 3 + 5
        }
        return sum
    }
    profile = profiler(fibonacciEfficient);
    console.log("       efficient result for limit 4000000", profile.call(null, 4000000));
    console.log(">>>>>>> ------------------------------------------------------------------------------ <<<<<<<");

/*
    https://projecteuler.net/problem=3
    ----------------------------------
    Largest prime factor

    Problem Statement:
        The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143?
 */

    /*
     * algorithm first calculate all 2 prime factors if any and to shorten the time we
     * divide n/i if i completely divides n so that we don't have to loop n times
     * this significantly reduce the runtime to O(n/i) where i is perfect divisor of n
     *
     * As constants does not matter for time compexity so time complexity will be O(n)
     */
    function largestPrimeFactors(n) {
        let largest = 0;

        // print all 2 prime factors
        while ( n % 2 === 0 ){
            largest = 2;
            n /= 2;
        }

        // as all 2's are covered so start with 3 and skip all even
        // numbers hence i += 2
        for (let i = 3; i <= parseInt(Math.sqrt(n)); i += 2) {
            while (n % i === 0) {
                largest = i;
                n /= i;
            }
        }

        // handle in case n is prime number
        if (n > 2) {
            largest = n;
        }

        return largest;
    }

    console.log("#### Problem3 (https://projecteuler.net/problem=3) ####");
    profile = profiler(largestPrimeFactors);
    console.log("       largest prime factor for 600851475143", profile.call(null, 600851475143));
    console.log(">>>>>>> ------------------------------------------------------------------------------ <<<<<<<");

/*
    https://projecteuler.net/problem=4
    ----------------------------------
    Largest palindrome product

    Problem Statement:
        A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
        Find the largest palindrome made from the product of two 3-digit numbers.
 */

    function isPalindrome(n) {
        let reverse = 0, tmp = n;

        // 117 reverse is
        // 117 % 10 = 7, 117/10 = 11
        // 11 % 10 = 1, 11/10 = 1
        // 711
        while (tmp > 0) {
            reverse = reverse * 10;
            reverse = reverse + tmp%10;
            tmp = parseInt(tmp/10);
        }

        // we can also use inbuild function of js
        // reverse = parseInt(Number(n).toString().split("").reverse().join(""));

        return reverse === n;
    }

    /*
     * This is normal iterative approach
     *
     * As we loop two times so time complexity is O(999) * O(999)
     * as this is dependent on number of times its looped so in big O notation its
     *
     * O(n*n)
     */
    function initialLargestPalindromeThreeDigit() {
        let maxPalindrome = 0;

        // i = 999
        // j = 999, 998, 997 .... 100
        // i = 998
        // j = 998, 997, 996 .... 100
        for (let i = 999; i >= 100; i--) {
            for (let j = i; j >= 100; j--) {
                let res = i * j;
                if (isPalindrome(res)) {
                    if (res > maxPalindrome) {
                        maxPalindrome = res;
                    }
                }
            }
        }

        return maxPalindrome;
    }

    console.log("#### Problem4 (https://projecteuler.net/problem=4) ####");
    profile = profiler(initialLargestPalindromeThreeDigit);
    console.log("       largest palindrome with two three digit numbers initial version", profile.call(null));
    console.log("");

    /* if we loop as per above function then we will have same number twice
     * for example 99900 when i = 999, j = 100 and also when i = 100, j = 900
     * so we can add a check when j >=i hence it will cut the loop to half
     *
     * so its time will be O(n*n/2) as compared to previous sub
     */
    function largestPalindromeThreeDigit() {
        let maxPalindrome = 0;

        // changed check to j >= i
        for (let i = 999; i >= 100; i--) {
            for (let j = 999; j >= i; j--) {
                let res = i * j;
                if (isPalindrome(res)) {
                    if (res > maxPalindrome) {
                        maxPalindrome = res;
                    }
                }
            }
        }

        return maxPalindrome;
    }

    profile = profiler(largestPalindromeThreeDigit);
    console.log("       largest palindrome with two three digit numbers", profile.call(null));
    console.log(">>>>>>> ------------------------------------------------------------------------------ <<<<<<<");

/*
    https://projecteuler.net/problem=5
    ----------------------------------
    Smallest multiple

    Problem Statement:
        2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
        What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
 */

    /*
     * calculate greatest common divisor, we will need this to caluclate lowest common multiple
     * as lcm(a, b) = a * b / gcd(a, b);
     */
    function gcd(a, b) {
        if (a === 0) {
            return b;
        }
        if (b === 0) {
            return a;
        }
        if (a === b) {
            return a;
        }

        let factor = 0;
        while (a % 2 === 0 && b % 2 === 0) {
            a /= 2;
            b /= 2;
            factor += 1;
        }

        while (a != b) {
            if(a % 2 === 0) {
                a /= 2;
            } else if(b % 2 === 0) {
                b /= 2;
            } else if(a > b) {
                a = (a - b)/2;
            } else {
                b = (b - a)/2;
            }
        }

        return a *  Math.pow(2, factor);
    }

    function lcm(a, b) {
        return parseInt( (a*b)/gcd(a, b) );
    }

    /*
     * As we traverse whole input so its time complexity is linear to size of input
     * so its O(n)
     *
     * for this problem we can start with 10 as its given 2520 is lowest multiple for
     * first 10 numbers to reduce time, i created it as generic one.
     */
    function smallestPossibleDivisible(n) {
        let result = 1;
        for (let i = 1; i <= n; i++) {
            result = lcm(result, i);
        }
        return result;
    }

    profile = profiler(smallestPossibleDivisible);
    console.log("       smalles possible evenly divisbile for all numbers till 20 is", profile.call(null, 20));
    console.log(">>>>>>> ------------------------------------------------------------------------------ <<<<<<<");


})();
