(function () {

/*
    function to calculate the time taken to execute a function,
    created as a wrapper for function calls to measure performance
 */
    function profiler(func) {
        return function() {
            let start = performance.now(),
                // as I am not passing arguments so using it directly
                // else use it like this let args = Array.from(arguments))
                returnVal = func.apply(this, arguments),
                end = performance.now(),
                duration = Number(end - start).toFixed(4),
                funcName = func.name;

            console.log(`       == Time take for ${funcName} was ${duration} ms`);
            return returnVal;
        };
    }

/*
    https://projecteuler.net/problem=1
    ----------------------------------

    Problem Statement:
        If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
        The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.
 */

    /*
     * this is normal looping based on input provided so time will increase linearly depending on input
     * as size of input increases time to calculate will increase
     *
     * O(n)
     */
    function linearWay(n) {
        let sum = 0;
        for (let i = 0; i < n; i++) {
          if (i % 3 === 0 || i % 5 === 0) {
            sum += i;
          }
        }
        return sum;
    }

    console.log("#### Problem1 (https://projecteuler.net/problem=1) ####");
    var profile = profiler(linearWay);
    console.log("       linear result for 1000", profile.call(null, 1000));
    console.log("       linear result for 10000", profile.call(null, 10000));
    console.log("       linear result for 1000000", profile.call(null, 1000000));
    console.log("");

    /*
     * this I learned later by looking on how to optimize it with the help of their suggestion, implemented
     * it just for learning it, got to learn gauss formula :)
     *
     * linearWay can have issues if n is very large, we can also solve it by making use of Gauss formula
     * i.e calculate sum individually for 3, 5, 15 using gauss formula, this way we can get rid of
     * looping through input
     *
     * Gauss formula to calculate sum all numbers till num is (num * (num + 1))/2
     *
     * with this way we have made this function independent of size of input
     *
     * O(1)
     */
    function sumDivisibleBy(num, n) {
        if (Number.isInteger(num) && Number.isInteger(n)) {
            let p = parseInt(num/n);
            return parseInt(n * (p * (p + 1)) / 2);
        }
        return 0;
    }

    function calculateSumGaussWay(num) {
        return sumDivisibleBy(num, 3) + sumDivisibleBy(num, 5) - sumDivisibleBy(num, 15);
    }

    profile = profiler(calculateSumGaussWay);
    console.log("       gauss way result for 1000", profile.call(null, 999));
    console.log("       gauss way result for 10000", profile.call(null, 9999));
    console.log("       gauss way result for 1000000", profile.call(null, 999999));

    console.log(">>>>>>> ------------------------------------------------------------------------------ <<<<<<<");

/*
    https://projecteuler.net/problem=2
    ----------------------------------

    Problem Statement:
        Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
            1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
        By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 */

    /*
     * as limit is defined so no need to pass any number for fibonacci, we will terminate based on limit 4000000
     * as we are looping so it will have linear time complexity so it will be
     * O(n) - increases with size of input
     */
    function fibonacciLinear(limit) {
        let a = 1,
            b = 0,
            sum = 0;

        while (a < limit) {
            // with es6 destructor no need to create temporary variable
            [a, b] = [b + a, a];

            // check if its even
            if (a % 2 === 0) {
                sum += a;
            }
        }

        return sum;
    }

    console.log("#### Problem2 (https://projecteuler.net/problem=2) ####");
    profile = profiler(fibonacciLinear);
    console.log("       linear result for limit 4000000", profile.call(null, 4000000));
    console.log("");

    /*
     * while analyzing the fibonacci series I came to realize one pattern for even that every third number is even
     * i never noticed it (eureka feeling :))
     * so with this function we can eliminate looping through all elements to check if they are even or not hence time
     * will reduce accordingly like O(n/3) as compared to previous one
     */
    function fibonacciEfficient(limit) {
        let a = 1,
            b = 1, // assigning b so that series start with 1, 1 to be consistent
            c = a + b, // 2
            sum = 0;

        while (c < limit) {
            sum += c;
            // for next loop 3 5 8 so a will be 3, b will be 5 and c will be 8
            a = b + c; // 1 + 2
            b = a + c; // 3 + 2
            c = a + b; // 3 + 5
        }
        return sum
    }
    profile = profiler(fibonacciEfficient);
    console.log("       efficient result for limit 4000000", profile.call(null, 4000000));
    console.log(">>>>>>> ------------------------------------------------------------------------------ <<<<<<<");

/*
    https://projecteuler.net/problem=3
    ----------------------------------

    Problem Statement:
        The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143?
 */

    /*
     * algorithm first calculate all 2 prime factors if any and to shorten the time we
     * divide n/i if i completely divides n so that we don't have to loop n times
     * this significantly reduce the runtime to O(n/i) where i is perfect divisor of n
     *
     * As constants does not matter for time compexity so time complexity will be O(n)
     */
    function largestPrimeFactors(n) {
        let largest = 0;

        // print all 2 prime factors
        while ( n % 2 === 0 ){
            largest = 2;
            n /= 2;
        }

        // as all 2's are covered so start with 3 and skip all even
        // numbers hence i += 2
        for (let i = 3; i <= parseInt(Math.sqrt(n)); i += 2) {
            while (n % i === 0) {
                largest = i;
                n /= i;
            }
        }

        // handle in case n is prime number
        if (n > 2) {
            largest = n;
        }

        return largest;
    }

    console.log("#### Problem3 (https://projecteuler.net/problem=3) ####");
    profile = profiler(largestPrimeFactors);
    console.log("       largest prime factor for 600851475143", profile.call(null, 600851475143));
    console.log(">>>>>>> ------------------------------------------------------------------------------ <<<<<<<");

})();
